<style>
binary_operators {
  color: orange;
}
keywords {
  color: blue;
}
keywords_bold {
    color: blue;
    font-weight: 700;
}
strings {
    color: green;

}
attention {
    color:cyan;
    font-weight: 700;
}
Classes {
    color:#00994c;
}
import
{
    color:#7f00ff;
}
NO
{
    text-decoration: line-through
}

</style>
# Code conventions  

> A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.  
  
## Таб или пробелы?  
> Spaces are the preferred indentation method.  

>Tabs should be used solely to remain consistent with code that is already indented with tabs. Python disallows mixing tabs and spaces for indentation. 

Отступ это четыре пробела.  
___
## Отступы  

<pre>многострочные конструкции нужно выделять (либо в вертикальные блоки,  
                                            штатными средствами редактора),
либо (
    выделять отступом и
    отдельной строкой):
вот так </pre>
<pre> Конструкция "if (" создаёт отступ, и этим может создать внешнюю путаницу с отступом для кода после объявления условий if.  

если (так 
        происходит)
    можно добавить отдельный отступ внутри условий если,
    чтобы явно отличать где начинаются операторы
Сам Python Enhancement Proposal (PEP) оставляет это на откуп пользователя.</pre>  
<pre>Скобку(
    закрывающую, многострочный,
    список аргументов
    )
можно(
    поставить как под первым не-пробельным( whitespace),
    символом так и в начале строки
).</pre>
___
## Длина строки    
\###############################################################################

**Не больше 79 знаков в строке.**
---  
\########################################################################  

Для многострочных блоков кода, например докстрингов, комментариев, много-  
уровневых блоков кода, длина строки не должна превышать 72 знака.  
Предпочитаемый способ разбиения строк- встроенный.  

Заворачиваем выражение в скобочку ({[ и оставляем её открытой в месте разрыва ]}).Лучше использовать скобки, а не бэкслэш.  
Бэкслэш _иногда_ можно применять. Например в конструкциях with:  

<pre><keywords_bold>with</keywords_bold> <keywords>open</keywords>(<strings>'/path/to/some/file/you/want/to/read'</strings>) <keywords>as</keywords> file_1, <attention>\</attention>
    <keywords>open</keywords>(<strings>'/path/to/some/file/being/written'</strings>, <strings>'w'</strings>) <keywords>as</keywords> file_2:  
     file_2<binary_operators>.</binary_operators>write(file_1<binary_operators>.</binary_operators>read())</pre>
В assert'ах тоже применяем бэкслеш.  
Независимо от метода переноса помним об отступах.  

**Придерживаясь регламента в этом вопросе, можем открывать несколько   
окон редактора без страданий.**   
## Линию разрывать до или после бинарного оператора*?
##### * Бинарный оператор создает новую переменную из двух других. Например =-*/  
Разрываем многоуровневый блок кода ДО оператора, сам оператор отделяем пробелом.  
<pre> чистая прибыль <binary_operators>=</binary_operators> ( 
    комиссия от заказов
    <binary_operators>+</binary_operators> взносы клиентов
    <binary_operators>-</binary_operators> (аренда <binary_operators>+</binary_operators> хозяйственные расходы)
    <binary_operators>-</binary_operators> налоги
    <binary_operators>-</binary_operators> зарплата
)</pre>

## Обрамление пустыми строками
<pre><br><br><binary_operators>Функции </binary_operators> <keywords>Головного_уровня</keywords> и <br><br>
<keywords>Классы</keywords> <Classes>Отделяются </Classes>
    <strings>"""двойной пустой строкой спереди и сзади."""</strings><br>
    <binary_operators>методы </binary_operators> <keywords>класса</keywords>
        отделяются одной строкой спереди и сзади<br><br><br></pre>
Можно _реже_ устанавливать дополнительные разрывы между логическими блоками, и наоборот убирать их для подчеркивания связности.

## Кодировки  
##### _улыбаемся и машем **большой студии**_  
Файлы **всегда** должны кодироваться в utf-8. Указывать кодировку не нужно.  
Пользуем ASCII символы, кроме обозначения имён и мест.
Если пользуем не-аски в качестве данных __почему в коде??__, то не пишем ересь типа ♥◘г╒╘▌╞┘╒♥z̯̯͡a̧͎̺l̡͓̫g̹̲o̡̼̘.. Не очень то и хотелось.  
Все имена только в аски, при этом лучше слова будут английские, если возможно. (ну как перевести слово 'borsch'?)
\* Кстати, шутка в том что борщ как раз так и переводится. Но это транскрипционный аналог.  
## Импорты
Импортируем каждый модуль отдельной строкой.
<pre><import>import</import> correct 
<import>import</import> way
<NO><import>import</import> bad, code</NO></pre>
Но можно импортировать функции из модуля одной строкой
<pre><import>from</import>  our_lib <import>import</import>  functions, right</pre>
Импорты собираем в одном месте. Вверху файла. После докстрингов. До глобальных переменных и констант.

Порядок импортирования:  
* стандартные библиотеки
* "relative third party imports" Т.е. тоже классные и сложные библиотеки, просто не от друзей Гвидо.
* библиотеки локального уровня, т.е. НАши :).

Уровни импортирования нужно разделять одинарной линией, можно даже написать комментарий что есть что...   
Рекомендуются абсолютные импорты..._никто не знает про venv_
Относительные импорты допускаются если абсолютное импортирование усложняет код. _конфликт версий?_
Импортируем кусочек модуля из полного, если это не вызывает конфликт имён.
<pre>
<import>from</import> myclass <import>import</import> MyClass
<import>from </import> foo.bar.yourclass <import>import</import> YourClass
a=MyClass
b=YourClass</pre>
Если конфликт всё же есть, импортируем так:
<pre>
<import>import</import> myclass
<import>import</import> foo.bar.yourclass
a=myclass.MyClass
b=foo.bar.yourclass.YourClass</pre>

> Wildcard imports (from <module> import *) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools.
## Module Level Dunder Names
##### ...или, "Мама, смотри, Я синьёр"
Модульные "х здесь навсегда" переменные 
<pre>'''This is the example module.

It does all and well.
'''
from __future__ import 
__version__ = '0.1'

__author__ = 'Cardinal Biggles'</pre>
вставляются после докстрингов, но перед импортами, КРОМЕ from \_\_future__ import- категории.   
## оффтоп. Что вообще такого особенного в future? C stackoverflow:
> Future statements are special -- they change how your Python module is parsed, which is why they must be at the top of the file. They give new -- or different -- meaning to words or symbols in your file. From the docs:
A future statement is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python. The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language. It allows use of the new features on a per-module basis before the release in which the feature becomes standard
## Кавычки
Всем всё равно. Но если в строке тоже есть кавычка, то внутренние и обрамляющие должны различаться, потому что бэкслэш усложняет чтение.  
**Но** внутри """троекратной строки""" кавычки используем "двойную кавычку, согласно pep257..._сколько их?_.
## Пустоты(whitespace) внутри выражений и  утверждений( присваиваний?)
|Не нужны вайтспейсы:  |пример|
|-|-|
после скобки  |Concat( first_string, second_string)
между запятой и закрывающей скобкой _зачем запятая?_ | Concat( first_string,)
сразу перед запятой, двоеточием, точкозапятой | if x == 4: print( x, y); x, y = y, x
перед скобкой обрамляющей аргументы функции| \_\_sum__( a, b)
перед скобкой среза |myDict['key']== myList[index]
чтобы выровнять ключи переменных| a = 1
с разной длиной названий |  long_name = 2

В целом **не** пользуем последовательность пробелов;  
Всегда оборачиваем бинарные операторы одним пробелом с каждой из сторон.  
<pre>
Для целей этой главы, бинарные операторы это:  
присвоение: <binary_operators>=</binary_operators>
дополненное присвоение: <binary_operators>+=</binary_operators>, <binary_operators>-=</binary_operators> и т.д.
операторы сравнения : <binary_operators>== < > != <> <= >= in, not in, is, is not </binary_operators> #запятые должны быть белыми, но там ТАКОЕ в коде странички :)
Boolean: <binary_operators>and</binary_operators>, <binary_operators>or</binary_operators>, <binary_operators>not</binary_operators></pre>
Если выражение содержит бинарные операторы разного уровня, лучше б.о. наинизшего приоритета обрамить пробелами:  

<pre>x <binary_operators>=</binary_operators> 2<binary_operators>*</binary_operators>a <binary_operators> + </binary_operators> 3<binary_operators>*</binary_operators>b
x <binary_operators>=</binary_operators> a <binary_operators>+</binary_operators> b
tmp <binary_operators> += </binary_operators>1
hyp_sqr<binary_operators> = </binary_operators>(a<binary_operators>*</binary_operators>a)<binary_operators> + </binary_operators>(b<binary_operators>*</binary_operators>b) </pre>
Function annotatation _примечания_ внутри скобок подчиняются обычным правилам скобок, а ожидаемый тип вывода **->** определяется как бинарный оператор  
Знак "=" для дефолтного значения аргументов пробелами не выделяется...
<pre>
<binary_operators>def</binary_operators> <keywords> pack_input</keywords>(firstString<binary_operators>=</binary_operators><strings>"Adam"</strings>, secondString<binary_operators>=</binary_operators><strings>"Smit"</strings>):
    <import>return</import> (firstString,secondString) </pre>
... кроме случаев что функция содержит аргументы по умолчанию И указания на тип ожидаемого аргумента
<pre>
<binary_operators>def</binary_operators> <keywords> pack_input</keywords>(firstString<binary_operators>:</binary_operators><strings>"Adam"</strings>, secondString<binary_operators> = </binary_operators><strings>"Smit"</strings>):</pre>
Порицается использование нескольких команд в одной строке( синтаксически это возможно, через точкозапятую оО)  
Циклы for, while нужно выделять в отдельную строку, с разной степенью критичности к codesmell.
## Когда использовать "trailing commas"- завершающие запятые
Они _не нужны_, кроме случаев что Мы объявляем tuple из одного элемента. В этом случае запятая- часть синтаксиса, и никуда Ты от неё не денешься. А опциональны- скобочки, как ни странно. Скобочку ставить НУЖНО потому что здесь так принято.  

Запятая помогает читать код в версионных программах, Мы стави её в коллекциях которые будут продолжены, в момент ...первичного назначения? 
При этом закрывающая скобка переносится на **другую** строку.
<pre>letters = [
    <strings>'aA'</strings>, <strings>'bB'</strings>,
    <strings>'cC'</strings>,
    ]</pre>
## Комментарии  
Комментарии не соответствующие коду хуже чем их отсутствие. Всегда 
специально обращаемся к актуализации комментариев.  
Комментарий должен быть полным предложением, начинающимся с большой 
буквы, кроме случаев что первое слово- имя переменной, начинающейся с 
нижней.  
Каждое предложение кроме последнего заканчиваем точкой **и двойным пробелом**.  
Пишем комментарии *для других*. Нужно на том языке, который поймет 
основная аудитория.  
Пишем комментарии на английском, кроме сценариев в которых код никогда 
не будет опубликован.  
## Блочные _локальные_ комментарии
Комментариям локального уровня присваиваем отступы уровня описываемого кода; выделяем решеткой и пробелом '# '.  
## Внутристрочные комментарии
**Реже.**  
Минимум два пробела после кода. Объявляем решеткой и пробелом "# ".
## Докстринги (ref pep 257 )
"""В pep 8 написано,   

что докстринг обрамляется тремя двойными  

кавычками. При этом закрывается такая кавычка на новой линии.  
"""  
""" Для докстринг-однострочников кавычки храним на одной линии."""  
Дальше из pep 257:  
Докстринг это строка (string literal...  
&nbsp;&nbsp;&nbsp;&nbsp;стринг литерал это строка которую Мы 
захардкодили. Когда Мы её выводим на экран, то это уже просто строка, 
в ней к примеру спецсимволы \n и \t заменены на перенос и отступ.
)... в первой строке модуля или функции. Именно позиционирование отличает докстринг от комментария; докстринг ловится стандартной функцией \_\_doc__ на правах справки.  
PEP предполагает наличие докстринга в каждом модуле, каждой функции модуля, в каждом классе, и каждом его методе.  
Литералы в других местах документа тоже могут быть документацией, но \_\_doc__ их не ловит.  
Некоторые среды разработки ловят:  
* докстринги сразу после присвоения значения переменной на верхнем уровне 
модуля, класса или \_\_init__. Такие докстринги называются "докстринги аттрибутов"
* Докстринги сразу после других докстрингов называются "дополнительные докстринги" Кто сказал "Сунь-Цзы"?

Есть два вида докстрингов: одно-  и много-строчники.

Однострочники нужны, под расчёску "докстринги должны быть везде".
НО раз уж они однострочные, то они должны быть очевидными. И кусочек слона должен быть ~~понятный~~ очевидный.  
* пользуем тройную кавычку, даже если комментарий однострочный. Так, его потом легче расширить.
* Открываем и закрываем кавычку на одной строке. Так _красиво_.
* Не обрамляем однострочник ньюлайнами ни с какой из сторон.
* **докстринг это предложение заканчивающееся точкой**. Она даёт эффект команды, а не описывает процесс. ( "Делает ЭТО", а не "возвращает переменную out" ).
* НЕ переписываем кусок кода. 

Многострочники, как и однострочники, - суть блока кода. С одним разрывом после тела литерала. Количество отступов по описываемому коду.

Многострочники скрипта должны объяснять его применение , и плюс-минус повторять инфо для случаев если аргументы не даны/даны не верно, или сразу вызвана -h справка

Многострочники модуля должны перечислить, и дать однострочник всех объектов- функций, классов, исключений, методов и пр.

Докстринги функций и методов должны включать их поведение, документировать
аргументы, возвратные значения, ...."side effects?" какие ещё побочные эффекты? Это о плохом коде? Может для дальнейшего рефакторинга..., вызываемые исключения, и ситуации когда ф/м вызывать нельзя.

Докстринг дочернего класса должен явно указать родителя и основные различия в их поведении. Если метод перезаписывается используем глагол overrride
## Имена переменных
...не сказано ЧТО пользовать, приведены примеры допустимого  
* о дна маленькая буква
* О дна большая буква
* lowercase
* lower_with_underscores( снэйк кейс)
* UPPERCASE
* UPPER_WITH_UNDERSCORES (capital snake case)
* CamelCase
* mixedCase
* Camel_With_Underscores (ugly!)

"Предложение..." объявляет маски:  
* _one_leading_underscore ненастаивающее внутреннее использование. "Не трогай, кроме случаев что знаешь что делаешь"
* one_trailing_underscore_ чтобы не пересекаться в пространстве имён со стандартными ключевыми словами, например class_ и class
* __double_leading_underscore: при объявлении аттрибута класса вызывает искажение имени, так реализуется сокрытие (inside class FooBar, __boo becomes _FooBar__boo)
* \_\_дандеры__ - "волшебные"- преднастроенные методы которые НЕ нужно перезаписывать... ну кроме случаев что Ты реально знаешь что делаешь или синьёр :)  

### Что при именовании делать нельзя
* использовать одинарные буквы L в нижнем регистре, i в Верхем, о в Верхнем.
* использовать не-ASCII символы 
### Советы по именованию
* имена модулей- короткие, только ловеркейсом. Подчеркивания- если упрощает чтение.
* пакеты- как модули, но лучше без подчеркиваний
* классы- CamelCase  
Можно называть как функцию, если класс хорошо задокументирован, и вызывается в основном как винтик другого процесса.
* для подклассов - CamelCase, лучше короткие имена  
Ковариантные( дочерний класс может пользовать метод(ы) родителя) и контравариантные связи (родительский класс может пользовать методы дочернего) нужно обозначать суффиксами _co и _contra
* Исключения должны быть классами, поэтому ориентируемся на обращение с классами- camelcase, **добавляем** суффикс Error 
* глобальные переменные(НЕ КОНСТАНТЫ)  именуются как функции( снэйк-кейсом). Советуют пользовать их в масштабе не крупнее одного модуля.
* имена функций и переменных следует писать снейк-кейсом;
mixedCase допускается для сохранения постоянства внутри модуля. Если весь код написан микседкейсом- продолжаем как было.
* именование аргументов функций и методов:  
первый аргумент метода объекта - **self**  
первый аргумент метода класса - **cls**  
если имя аргумента функции/метода конфликтует с зарезервированным ключевым словом, то нужно добавить знак подчеркивания в конец имени, а не писать аббревиатуру или деформировать "нормальное" слово. Или можно присвоить синоним.
* имена методов и _поля **объектов**_ - снэйк кейс.  
Для не-публичных методов и полей объектов ставим один предварительный знак подчеркивания  
Чтобы предотвратить конфликт имён с подклассами используем двойной предварительный знак подчеркивания
* константы объявляем на уровне модуля, (_и желательно повыше?_). Верхним снейк-кейсом

## Дизайн наследования
Всегда определяемся с тем является ли поле или метод публичным или приватным. Если уверенности нет- делаем приватным.  
Публичные поля- те которые Мы доверяем в пользование _unrelated_ юзерам, третьей стороне.  
Соответственно приватные поля не должны быть инструментами конечного пользователя _чтобы ему не пришлось потом переучиваться_. Бэкэнд- Наша кухня. Гарантий того что он не изменится завтра или даже не будет удалён, сломав быт пользователя,- Мы не даём.  
Понятие приватный,- весьма условное, в Пайтон сложно что-то спрятать.  
Другая категория методов и полей- защищенные, или же "подкласс API". Соответственно некоторые классы проектируются так чтобы быть унаследованными. Если делаем такой- нужно озвучивать в коде решения о видимости полей и методов...  
**Для этого делаем вот что:**  
* публичные поля не должны быть обрамлены знаками подчеркивания спереди
* если поле пересекается в пространстве имен с зарезервированным оператором - ставим после знак подчеркивания( кроме cls как первый аргумент классового метода)
* для публичной информации открываем только имя результата, а расчётную часть прячем   
 * * Функции классов должны делать только то что должны, без "побочных эффектов"
 * * Поля не должны быть алгоритмически дорогими.
 * внутренние поля класса-родителя( не наследуемые) выделяются двойным предварительным знаком подчеркивания

 # Рекомендации к написанию кода
***
В требовательных к быстродействию или критичных к устойчивости программах синтаксический сахар пользовать **не нужно**.  
Например строки нужно соединять не через a += b, а через a.join(b)  
Дело в том что разные интерпретаторы могут по разному или хотя бы с разной скоростью обрабатывать один и тот же код.

Сравнения с синглтонами( объекты класса существующие в единственном экземляре -- НАПРИМЕР ТИПЫ(int,str...)), и None проводятся через **is** и **is not**

Если сравниваем переменную с None, то указываем явно **if x is not None** потому что в случае **if x** , переменная может получить значение совпадающее с **False** в булево, тот же ноль. При этом  программа продолжит выполняться по None сценарию.

Когда собираемся работать со сравнениями, нужно делать полный спектр операций ( \_\_eq__ , \_\_ne__ , \_\_lt__ , \_\_le__ , \_\_gt__ , \_\_ge__ ), а не надеятся что "и так норм". Дело не в том даже, что у нас должен быть полный функционал, а в том что интрепретатор при переводе высокоуровневого кода в байт-код( и потом в бинарный), может менять переменные местами с изменением полярности оператора сравнения. Получится "не хорошо".

Если выбираем между полным определение функции и лямбдой: выбираем полную функцию.
<pre>
# Correct:
def f(x): return 2*x
# Wrong:
f = lambda x: 2*x
</pre>
<pre>
x_lambded= <binary_operators>lambda</binary_operators> a: a+10
<binary_operators>def</binary_operators> <keywords>x_defed</keywords>(a: <import>int</import>) -> <import>int</import>:
    <binary_operators>return</binary_operators> a+10

<import>globals</import>()
<keywords>{</keywords>'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)>, 
<u>'x_lambded': &lt;function &lt;lambda> at 0x0000021D630A69E0></u>, 
<u>'x_defed': &lt;function x_defed at 0x0000021D630A6A70><keywords></u>
} </keywords>
</pre>
В лямбдовой функции на один указатель меньше, в каких-то совсем аховых ситуациях отладки это может помешать :).  

Со стак оверфлоу, правда субъективщина:
> In general, the main argument against doing this is that def statements will result in more lines of code. My main response to that would be: yes, and that is fine. Unless you are code golfing, minimising the number of lines isn't something you should be doing: go for clear over short.

Наследуем исключения из Exception, а не BaseException. Предполагается что BaseException мы храним на случай ошибок которые лучше исправлять перезапуском приложения, а не исправлять на лету.

Проектируя исключения, стараемся сразу дать намёк на исправление, т.е. "что делать" вместо "кто виноват".

Используя передачу исключений **raise** \<exceptionDesired> **from** \<exceptionThrown>, нужно сохранить вывод первичного исключения, чтобы было упростить корректировку.

Когда ловим исключения, если возможно, уточняем какое исключение ловим.  
Например KeyboardInterrupt и ImportError скорее всего требуют разной обработки. 

Блоки кода внутри try ужимаем максимально. Это помогает локализовать баги.

Если ресурс используется локально, открываем его через with, чтобы он закрылся без проишествий, и память очистилась своевременно.

**NB**: Если при создании класса создаём методы \_\_enter__ и \_\_exit__,
сможем применять к объектам with! _"Такой объект Тебе нужен"_-  Сунь- Цзы :D  
Соответственно \_\_enter__ описывает соединение с источником, а \_\_exit__ - ,безопасное завершение взаимодействия. 

Постоянство распространяется на возвраты функций и методов.  
Это значит что нужно выбрать, возвращаем Мы None всех местах где это применимо, или не возвращаем нигде. Больше того. Если хотя бы одна ветка функции возвращает значение, все ветки должны явно возвращать значение. Если это None, то пишем ей на лбу **return None**, а не return и и не "".

Пользуем **"".startswith()** и **"".endswith()**, везде где применимо, вместо срезов **""[:]**. Стандартные методы чище по ошибкам и читается легче.  
Срезы компилятся дольше.

Сравнение типов нужно проводить через isinstance(), и никогда- прямо
<pre>isinstance("right",str)
type("wrong") is int</pre>

Для последовательностей( строки, списки , ~~кортежи~~ tuple) помним и применяем что пустые объекты дают False.
<pre>
# если там пусто:
if not seq:
# если там есть что-то
if seq:
# важно! список нулей, список None, список False дают на выходе True.
# False даёт только последовательность длинной 0 элементов
</pre>
 Не пишем литералы которые функционируют вокруг вайтспейсов; они неочевидны для глаза, а некоторые редакторы( тот же vsc в пространстве markdown ) их вообще обрезают!

Не сравниваем булевы с True или False. 

_correct:_  
if greeting: # true  
_wrong:_
if greeting == True:  
if greeting is True:
  
Пользовать операторы управления потоком return/ break/ continue - внутри обработки исключений try .. finally не рекомендуют, потому что они могут выбросить из finally, не дав обработать ошибку до конца.

По аннотациям к переменным указали ещё один PEP 526.  
Там _нужно написать отдельную методичку_ . Если взять самое простое из нужного: список интов мы называем списком интов так:
<pre>from typing import List
def printList( list_i:List[int]) -> None:  
    print( list_i)  
    return None
</pre>  
Подсказку по типу можно реализовать не как комментарий, уже есть конструкция для этого
<pre>
from typing import Tuple
# corrrect
# whitespace after
a: int
# wrong
# double framed
a : int
# no frames
b:str 
# для аттрибутов класса: 
class Example:
    # right
    coords: Tuple[int,int]
    label: str = '&lt;unknown>'
    # wrong
    # equality sign unframed 
    result: int=0
</pre>